import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as h,f as k,d as l,g as n,b as i,a as t,r as e,o as r}from"./app-CySHXAx9.js";const d="/assets/1725955590636-baea581b-0b91-4398-8626-323aa9f5d09d-484310-zASF50_c.png",g="/assets/1725957587400-3d016b85-001a-449f-b194-9cef27e642e5-901617-CdwUkr6k.png",A="/assets/1725957714767-b8c69d18-a673-47e6-acd4-abb1aafb33fa-191053-vmpBkgbm.png",y="/assets/1725957739134-bc97fb3b-8d48-4722-aede-9e3263a7ca1a-561982-75xeeaDO.png",o="/assets/1725957989414-e0660f2d-18f5-4c61-8313-e48a1746d138-541877-BwQe2k31.png",B="/assets/1725963493570-7242bb8f-23a2-4067-8b5b-a7df65499d18-545799-BwnHwVuE.png",u="/assets/1725964683261-34a0a71d-56f8-4397-9156-16b5ac4f7371-600965-BafymiSn.png",b="/assets/1725965215890-ae5620fd-ef23-4f55-bec3-ae34b2cf0fff-283182-CUc0TJM0.png",m={};function C(F,s){const a=e("font");return r(),h("div",null,[s[71]||(s[71]=k('<h1 id="kmp-算法" tabindex="-1"><a class="header-anchor" href="#kmp-算法"><span>KMP 算法</span></a></h1><h2 id="引言" tabindex="-1"><a class="header-anchor" href="#引言"><span>引言</span></a></h2><h3 id="字符串匹配问题的概念" tabindex="-1"><a class="header-anchor" href="#字符串匹配问题的概念"><span>字符串匹配问题的概念</span></a></h3><p>给定一个主串和模式串，要求判断模式串是不是主串中的子串。</p>',4)),l(a,{style:{color:"rgb(34, 34, 34)"}},{default:n(()=>s[0]||(s[0]=[i(" 在这种问题中，我们一般将短的字符串称为 ")])),_:1}),s[72]||(s[72]=i(" **")),l(a,{style:{color:"rgb(34, 34, 34)"}},{default:n(()=>s[1]||(s[1]=[i(" 模式串 ")])),_:1}),s[73]||(s[73]=i("** ")),l(a,{style:{color:"rgb(34, 34, 34)"}},{default:n(()=>s[2]||(s[2]=[i("，将长的字符串称为 ")])),_:1}),s[74]||(s[74]=i(" **")),l(a,{style:{color:"rgb(34, 34, 34)"}},{default:n(()=>s[3]||(s[3]=[i(" 文本串。")])),_:1}),s[75]||(s[75]=i("**")),s[76]||(s[76]=t("figure",null,[t("img",{src:d,alt:"字符串匹配示例",tabindex:"0",loading:"lazy"}),t("figcaption",null,"字符串匹配示例")],-1)),t("p",null,[s[5]||(s[5]=i("可以看出，")),l(a,{style:{color:"rgb(34, 34, 34)"}},{default:n(()=>s[4]||(s[4]=[i(" 字符串 B 在字符串 A 中出现的位置为 2，因此返回结果为 2。")])),_:1})]),s[77]||(s[77]=k(`<h3 id="解决字符串匹配问题的算法" tabindex="-1"><a class="header-anchor" href="#解决字符串匹配问题的算法"><span>解决字符串匹配问题的算法</span></a></h3><p>解决字符串匹配问题的算法很多，大致有 BF(暴力破解)算法，KMP 算法，Boyer-Moore，Sunday 算法等。其中比较著名的算法为 KMP 算法，这里稍微记录一下 <strong>目前</strong> 我个人对 KMP 算法的理解。</p><h2 id="朴素方法-暴力匹配" tabindex="-1"><a class="header-anchor" href="#朴素方法-暴力匹配"><span>朴素方法(暴力匹配)</span></a></h2><h3 id="基本思路" tabindex="-1"><a class="header-anchor" href="#基本思路"><span>基本思路</span></a></h3><p>顾名思义，这种方法不关注任何信息，<strong>直接枚举文本串中的匹配起始点</strong>。</p><ul><li>若文本串中 <strong>当前</strong> 匹配点上的字符与模式串中当前匹配点对应的字符相同，则将两个串的匹配点后移。</li><li>若不同，则重置模式串中的匹配点至模式串起始位置，并重新枚举文本串中的匹配点。</li><li>过程持续至文本串的匹配点或模式串中的匹配点超过其长度。</li></ul><p>示例代码如下所示：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Solution</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> strStr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> ss</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> pp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> ss</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(), m </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> pp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">        char</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">s</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> ss</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toCharArray</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(), p </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> pp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toCharArray</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 枚举原串的匹配起始点</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> m; i++) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 从原串的匹配起始点和匹配串的起始位置开始，尝试匹配</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i, b </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (b </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> m </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> s[a] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p[b]) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                a++;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                b++;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 如果能够完全匹配，返回原串的匹配起始点下标</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (b </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> m) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 找不到，返回-1</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="时间复杂度分析" tabindex="-1"><a class="header-anchor" href="#时间复杂度分析"><span>时间复杂度分析</span></a></h3><p>若文本串的长度为 $ n $，模板串的长度为 $ m $，则时间复杂度容易达到 $ O(n * m) $ 这个量级。</p><blockquote><p>最坏情况下需要枚举 $ n(或n - m)次 $，枚举的长度最坏情况下可以达到 $ (m - 1) $ 次</p></blockquote><h2 id="kmp-算法-1" tabindex="-1"><a class="header-anchor" href="#kmp-算法-1"><span>KMP 算法</span></a></h2><h3 id="kmp-算法介绍" tabindex="-1"><a class="header-anchor" href="#kmp-算法介绍"><span>KMP 算法介绍</span></a></h3>`,13)),l(a,{style:{color:"rgb(34, 34, 34)"}},{default:n(()=>s[6]||(s[6]=[i(" Knuth-Morris-Pratt 算法是一种比较高效的字符串匹配算法，它能够以 ")])),_:1}),s[78]||(s[78]=i(" $ O(n + m) $ ")),l(a,{style:{color:"rgb(34, 34, 34)"}},{default:n(()=>s[7]||(s[7]=[i(' 的时间复杂度解决 "找到子串出现在主串中第一次出现的位置" 这类问题。KMP 算法对 BF 算法中舍弃掉的匹配信息加以利用，这一点是 KMP 算法相比于朴素算法的优化核心。')])),_:1}),s[79]||(s[79]=t("h3",{id:"个人对-kmp-算法原理的大致理解",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#个人对-kmp-算法原理的大致理解"},[t("span",null,"个人对 KMP 算法原理的大致理解")])],-1)),s[80]||(s[80]=t("blockquote",null,[t("p",null,"这部分会借用一些大佬的图加以解释")],-1)),s[81]||(s[81]=t("p",null,[i("相比于 BF 算法将之前产生的匹配信息全部扔掉，KMP 算法则将产生的匹配信息进行了利用，"),t("strong",null,"减少了模板串匹配指针的回溯程度，同时让文本串的匹配指针不进行回溯"),i("。")],-1)),s[82]||(s[82]=t("p",null,"KMP 算法的执行步骤大致如下：",-1)),t("ol",null,[s[33]||(s[33]=t("li",null,"初始的匹配过程与 BF 一致，相同则匹配点后移",-1)),t("li",null,[s[12]||(s[12]=i("若发现不匹配，先取之前匹配的部分：")),s[13]||(s[13]=t("br",null,null,-1)),s[14]||(s[14]=t("img",{src:g,alt:"匹配失败时的操作-1",loading:"lazy"},null,-1)),s[15]||(s[15]=t("br",null,null,-1)),s[16]||(s[16]=i(" 然后在先前匹配成功的蓝色部分中，得出该蓝色部分字串对应的 ")),t("strong",null,[l(a,{style:{color:"rgb(34, 34, 34)"}},{default:n(()=>s[8]||(s[8]=[i(" 最长相同前后缀 ")])),_:1})]),s[17]||(s[17]=i()),l(a,{style:{color:"rgb(34, 34, 34)"}},{default:n(()=>s[9]||(s[9]=[i("(")])),_:1}),s[18]||(s[18]=i()),t("strong",null,[l(a,{style:{color:"rgb(34, 34, 34)"}},{default:n(()=>s[10]||(s[10]=[i(" 绿色 ")])),_:1})]),s[19]||(s[19]=i()),l(a,{style:{color:"rgb(34, 34, 34)"}},{default:n(()=>s[11]||(s[11]=[i(" 区域)")])),_:1}),s[20]||(s[20]=i("：")),s[21]||(s[21]=t("br",null,null,-1)),s[22]||(s[22]=t("img",{src:A,alt:"匹配失败操作-2",loading:"lazy"},null,-1)),s[23]||(s[23]=i()),s[24]||(s[24]=t("img",{src:y,alt:"匹配失败操作-3",loading:"lazy"},null,-1)),s[25]||(s[25]=t("br",null,null,-1)),s[26]||(s[26]=i(' 最后将模式串 "后移" 至前缀与文本串的后缀相同的部分(其实是通过 ')),s[27]||(s[27]=t("strong",null,"移动模板串匹配点至蓝色区域前缀的后一个字符处",-1)),s[28]||(s[28]=i(" 来等效实现的，文本串匹配点 ")),s[29]||(s[29]=t("strong",null,"无需回溯",-1)),s[30]||(s[30]=i(")")),s[31]||(s[31]=t("br",null,null,-1)),s[32]||(s[32]=t("img",{src:o,alt:"1725957989414-e0660f2d-18f5-4c61-8313-e48a1746d138.png",loading:"lazy"},null,-1))]),s[34]||(s[34]=t("li",null,"若成功匹配模板串，则返回文本串匹配点对应的下标；否则返回-1。",-1))]),s[83]||(s[83]=t("p",null,"在对 KMP 算法的原理进行分析过后，可以发现该算法实现的核心要点在于：",-1)),t("p",null,[s[36]||(s[36]=t("strong",null,"在匹配失败时，获取已匹配段的",-1)),s[37]||(s[37]=i()),t("strong",null,[l(a,{style:{color:"rgb(34, 34, 34)"}},{default:n(()=>s[35]||(s[35]=[i(" 最长相同前后缀信息，以让模板串匹配位置尽可能少回溯的同时，无需让文本串匹配位置回溯。")])),_:1})])]),l(a,{style:{color:"rgb(34, 34, 34)"}},{default:n(()=>s[38]||(s[38]=[i(" 那么如何获得已匹配段的最长相同前后缀信息呢？")])),_:1}),l(a,{style:{color:"rgb(34, 34, 34)"}},{default:n(()=>s[39]||(s[39]=[i(" 通过上面的分析，我们可以得到以下两点：")])),_:1}),s[84]||(s[84]=k('<ol><li>已匹配段一定是 <strong>模板串的子串，</strong> 也一定是 <strong>文本串的子串</strong>。</li><li>模板串是固定的 =&gt; 对于模板串的每一个元素来说，它之前的所有元素组成的子串是固定的。</li></ol><p>因此，对于已匹配段的任意一种 <strong>状态</strong>，已匹配段的最长相同前后缀信息是 <strong>固定</strong> 的。</p><blockquote><p>状态：此处指已匹配段的 <strong>长度</strong> 取值情况</p></blockquote><p>既然这个信息是 <strong>固定且不受文本串影响</strong> 的，那么我们就可以先对这个信息进行 <strong>预处理</strong>，等到匹配失败的时候使用得到的信息对模板串匹配位置的回溯进行优化即可。</p><h3 id="部分匹配表-pmt-与-next-数组" tabindex="-1"><a class="header-anchor" href="#部分匹配表-pmt-与-next-数组"><span>部分匹配表 PMT 与 Next 数组</span></a></h3><p>要得出 <strong>每一个</strong> 已匹配段状态对应的最长相同前后缀信息，我们需要 <strong>枚举</strong> 每一种已匹配段状态，得出其对应的最长相同前后缀信息，并存储到一个数据结构中，方便之后取用信息。</p><p>而在 KMP 算法中，部分匹配表 PMT 就起到了存储每一种已匹配段状态所对应的信息的作用。</p><h4 id="pmt-表的生成-人工法" tabindex="-1"><a class="header-anchor" href="#pmt-表的生成-人工法"><span>PMT 表的生成(人工法)</span></a></h4><p>举个例子，对于字符串 &quot;abababca&quot;，它的 PMT 表取值如下：</p><figure><img src="'+B+'" alt="该字符串中 PMT 表的值" tabindex="0" loading="lazy"><figcaption>该字符串中 PMT 表的值</figcaption></figure>',10)),t("p",null,[s[42]||(s[42]=i("如上图所示，可以发现，")),t("strong",null,[l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[40]||(s[40]=[i(" PMT 中的值就是当前 ")])),_:1})]),s[43]||(s[43]=i()),s[44]||(s[44]=t("strong",null,"已匹配段状态",-1)),s[45]||(s[45]=i()),t("strong",null,[l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[41]||(s[41]=[i(" 的前缀集合与后缀集合的交集中最长元素的长度。")])),_:1})])]),l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[46]||(s[46]=[i(" 例如 ")])),_:1}),s[85]||(s[85]=i(" 已匹配段状态为 ")),l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[47]||(s[47]=[i(' "ababab" 时，其 ')])),_:1}),s[86]||(s[86]=i(" **")),l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[48]||(s[48]=[i("(真)")])),_:1}),s[87]||(s[87]=i("** ")),l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[49]||(s[49]=[i(" 前缀集合为 ")])),_:1}),s[88]||(s[88]=i(" $ \\{ a, ab, aba, abab, ababa\\} $ ")),l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[50]||(s[50]=[i("，")])),_:1}),s[89]||(s[89]=i(" **")),l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[51]||(s[51]=[i("(真)")])),_:1}),s[90]||(s[90]=i("** ")),l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[52]||(s[52]=[i(" 后缀集合为 ")])),_:1}),s[91]||(s[91]=i(" $ \\{ b, ab, bab, abab, babab \\} $ ")),l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[53]||(s[53]=[i("，它们的交集为 ")])),_:1}),s[92]||(s[92]=i(" $ \\{ ab, abab \\} $ ")),l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[54]||(s[54]=[i("，交集中最长元素的长度为 ")])),_:1}),s[93]||(s[93]=i(" $ 4 $ ")),l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[55]||(s[55]=[i("，因此下标为 5 的字符 b 对应的 PMT 表取值为 ")])),_:1}),s[94]||(s[94]=i(" $ 4 $ ")),l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[56]||(s[56]=[i("。")])),_:1}),s[95]||(s[95]=k('<h4 id="如何使用-pmt-表加速字符串的查找" tabindex="-1"><a class="header-anchor" href="#如何使用-pmt-表加速字符串的查找"><span>如何使用 PMT 表加速字符串的查找</span></a></h4><blockquote><p>本部分内容借鉴了 <a href="https://www.zhihu.com/question/21923021/answer/281346746" target="_blank" rel="noopener noreferrer">该问题</a> 中大佬的回答</p></blockquote><p>如下图所示，要在文本串 &quot;ababababca&quot; 中查找模式字符串 &quot;abababca&quot;。</p><p>如果在 j 处字符不匹配，那么由于模式字符串 PMT 的性质，文本串中 i 指针之前的 PMT [j −1] 位 <strong>(文本串中已匹配串的后缀)</strong> 就一定与模式字符串的第 0 位至第 PMT [j−1] 位 <strong>(模板串中已匹配串的前缀)</strong> 是相同的。</p><p>这是因为文本串在 i 位失配，也就意味着文本串从 i−j 到 i 这一段是与模板串的 0 到 j 这一段是完全相同的。而我们上面也解释了，模板串从 0 到 j−1 ，在这个例子中就是”ababab”，其真前缀集合与真后缀集合的交集的最长元素为”abab”， 长度为 4。</p><p>所以就可以断言，文本串中 i 指针之前的 4 位一定与模式字符串的第 0 位至第 4 位是相同的，即长度为 4 的后缀与前缀相同。这样一来，我们就可以将这些字符段的比较省略掉。<strong>具体的做法是，保持 i 指针不动，然后将 j 指针指向模板串的 PMT [j −1] 位即可。</strong></p><p>简言之，以图中的例子来说，在 i 处失配，那么文本串和模板串的前边 6 位就是相同的。又因为模板串的前 6 位，它的前 4 位前缀和后 4 位后缀是相同的，所以我们推知文本串 i 之前的 4 位和模板串开头的 4 位是相同的。就是图中的灰色部分。那这部分就不用再比较了。</p><figure><img src="'+u+'" alt="KMP 算法示意图" tabindex="0" loading="lazy"><figcaption>KMP 算法示意图</figcaption></figure>',8)),l(a,{style:{color:"rgb(138, 143, 141)"}},{default:n(()=>s[57]||(s[57]=[i('(注意：图中描述的 "已匹配段" 实为 ')])),_:1}),s[96]||(s[96]=i(" **")),l(a,{style:{color:"rgb(138, 143, 141)"}},{default:n(()=>s[58]||(s[58]=[i(" 文本串中的已匹配段 ")])),_:1}),s[97]||(s[97]=i("** ")),l(a,{style:{color:"rgb(138, 143, 141)"}},{default:n(()=>s[59]||(s[59]=[i("，不是模板串的)")])),_:1}),s[98]||(s[98]=k('<p>有了上面的思路，我们就可以使用 PMT 加速字符串的查找了。我们看到如果是在 j 位 失配，那么影响 j 指针回溯的位置的其实是第 j −1 位的 PMT 值，所以为了编程的方便， 我们不直接使用 PMT 数组，而是将 PMT 数组向后偏移一位。我们把新得到的这个数组称为 <strong>Next 数组</strong>。</p><p>其中要注意的一个技巧是，在把 PMT 进行向右偏移时，第 0 位的值，我们将其设成了-1，这只是为了编程的方便，并没有其他的意义。在上面提到的例子中，Next 数组如下表所示。</p><figure><img src="'+b+`" alt="由 PMT 表右移一项得出的 Next 数组" tabindex="0" loading="lazy"><figcaption>由 PMT 表右移一项得出的 Next 数组</figcaption></figure><p>下面给出根据 Next 数组进行字符串匹配加速的字符串匹配示例程序：</p><div class="language-java line-numbers-mode has-collapsed-lines collapsed" data-highlighter="shiki" data-ext="java" data-title="java" style="--vp-collapsed-lines:20;--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> KMP</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> text</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> pattern) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 文本串指针</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 模式串指针</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">[] next </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">pattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 初始化 Next 数组</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    getNext</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(pattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> next)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 生成 Next 数组</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> text</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> pattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ||</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> text</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">charAt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i)</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> pattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">charAt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(j)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 匹配成功，文本串和模式串指针同时后移</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            j</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> next[j]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 失配时，使用 Next 数组跳转</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> pattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> j</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 匹配成功，返回匹配起始位置</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 未匹配</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="collapsed-lines"></div></div><h4 id="如何通过编程快速获取-next-数组" tabindex="-1"><a class="header-anchor" href="#如何通过编程快速获取-next-数组"><span>如何通过编程快速获取 Next 数组？</span></a></h4><p>在 3.3.2 节中我们已经了解了 PMT 表与 Next 数组之间的关系，只要能求得 PMT 表，就能够求出 Next 数组。</p>`,7)),t("p",null,[s[62]||(s[62]=i("上文中 PMT 表的定义为：")),l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[60]||(s[60]=[i(" PMT 中的值就是当前 ")])),_:1}),s[63]||(s[63]=i(" 已匹配段状态 ")),l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[61]||(s[61]=[i(" 的前缀集合与后缀集合的交集中最长元素的长度。")])),_:1})]),l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[64]||(s[64]=[i(" 那么，获取 PMT 表的过程，相当于模板串自身和自身进行匹配的过程。")])),_:1}),l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[65]||(s[65]=[i(" 为了方便，我们一般都略过求 PMT 表的过程，直接求解 Next 数组，其实原理也是一样的。")])),_:1}),l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[66]||(s[66]=[i(" 直接求解 Next 数组的大致思路描述如下：")])),_:1}),l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[67]||(s[67]=[i(" 令一份模板串为文本串，然后从模板串下标为 1 的位置进行匹配(可以这么理解：PMT 表右移一项就是 Next 表了)，在任一位置，")])),_:1}),s[99]||(s[99]=i(" **")),l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[68]||(s[68]=[i(" 能匹配的最长长度 ")])),_:1}),s[100]||(s[100]=i("** ")),l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[69]||(s[69]=[i(" 就是当前位置的 Next 值。")])),_:1}),l(a,{style:{color:"rgb(25, 27, 31)"}},{default:n(()=>s[70]||(s[70]=[i(" 获取 Next 数组的示例代码如下：")])),_:1}),s[101]||(s[101]=k(`<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getNext</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> pattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] next) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    next[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 初始化 Next 数组的第一个值</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // i 指向当前字符，j 指向最大相同前后缀长度</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> pattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) { </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 遍历模式串</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ||</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> pattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">charAt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i)</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> pattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">charAt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(j)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            j</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            next[i] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> j</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 记录最大相同前后缀长度</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> next[j]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 如果不匹配，则回溯 j</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li><strong>KMP 算法的优势</strong> 在于减少了无效的比较，使得模式串的匹配指针尽可能少地回溯，而文本串的指针则无需回溯。</li><li><strong>常见问题与难点：</strong> 如何生成 PMT 表和 Next 数组？关键在于理解前缀和后缀的概念，以及如何通过匹配信息来优化下一步的匹配。</li></ul>`,3))])}const E=p(m,[["render",C],["__file","KMP-algorithm.html.vue"]]),D=JSON.parse('{"path":"/zh/note/algorithm/KMP-algorithm.html","title":"KMP算法","lang":"zh-CN","frontmatter":{"title":"KMP算法","order":1,"icon":"pen-to-square","categories":["算法"],"tags":["字符串匹配","Next数组","KMP算法"],"description":"KMP 算法 引言 字符串匹配问题的概念 给定一个主串和模式串，要求判断模式串是不是主串中的子串。 **** ****字符串匹配示例字符串匹配示例 可以看出， 解决字符串匹配问题的算法 解决字符串匹配问题的算法很多，大致有 BF(暴力破解)算法，KMP 算法，Boyer-Moore，Sunday 算法等。其中比较著名的算法为 KMP 算法，这里稍微记录...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/zh/note/algorithm/KMP-algorithm.html"}],["meta",{"property":"og:site_name","content":"文档演示"}],["meta",{"property":"og:title","content":"KMP算法"}],["meta",{"property":"og:description","content":"KMP 算法 引言 字符串匹配问题的概念 给定一个主串和模式串，要求判断模式串是不是主串中的子串。 **** ****字符串匹配示例字符串匹配示例 可以看出， 解决字符串匹配问题的算法 解决字符串匹配问题的算法很多，大致有 BF(暴力破解)算法，KMP 算法，Boyer-Moore，Sunday 算法等。其中比较著名的算法为 KMP 算法，这里稍微记录..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-02T13:33:24.000Z"}],["meta",{"property":"article:tag","content":"字符串匹配"}],["meta",{"property":"article:tag","content":"Next数组"}],["meta",{"property":"article:tag","content":"KMP算法"}],["meta",{"property":"article:modified_time","content":"2024-12-02T13:33:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"KMP算法\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-02T13:33:24.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"codePJCP2\\",\\"url\\":\\"https://docs.pjcp2-personal.cn/zh/\\"}]}"]]},"headers":[{"level":2,"title":"引言","slug":"引言","link":"#引言","children":[{"level":3,"title":"字符串匹配问题的概念","slug":"字符串匹配问题的概念","link":"#字符串匹配问题的概念","children":[]},{"level":3,"title":"解决字符串匹配问题的算法","slug":"解决字符串匹配问题的算法","link":"#解决字符串匹配问题的算法","children":[]}]},{"level":2,"title":"朴素方法(暴力匹配)","slug":"朴素方法-暴力匹配","link":"#朴素方法-暴力匹配","children":[{"level":3,"title":"基本思路","slug":"基本思路","link":"#基本思路","children":[]},{"level":3,"title":"时间复杂度分析","slug":"时间复杂度分析","link":"#时间复杂度分析","children":[]}]},{"level":2,"title":"KMP 算法","slug":"kmp-算法-1","link":"#kmp-算法-1","children":[{"level":3,"title":"KMP 算法介绍","slug":"kmp-算法介绍","link":"#kmp-算法介绍","children":[]},{"level":3,"title":"个人对 KMP 算法原理的大致理解","slug":"个人对-kmp-算法原理的大致理解","link":"#个人对-kmp-算法原理的大致理解","children":[]},{"level":3,"title":"部分匹配表 PMT 与 Next 数组","slug":"部分匹配表-pmt-与-next-数组","link":"#部分匹配表-pmt-与-next-数组","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1733146404000,"updatedTime":1733146404000,"contributors":[{"name":"codePJCP2","email":"159783914+codePJCP2@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":10.53,"words":3158},"filePathRelative":"zh/note/algorithm/KMP-algorithm.md","localizedDate":"2024年12月2日","autoDesc":true}');export{E as comp,D as data};
