import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as s,b as e,e as t,f as n,o as p}from"./app-CySHXAx9.js";const h="/assets/image-20241201163251453-CeKuJTOV.png",r="/assets/image-20241201163536616-DKt7di2g.png",o="/assets/image-20241201191717027-UdbBjcNX.png",d="/assets/image-20241201183046718-BMfIYlF3.png",k={};function c(g,i){return p(),a("div",null,[i[0]||(i[0]=s("blockquote",null,[s("p",null,[s("strong",null,"背景回顾"),e("：整个计算机系统世界的 “创建” 从 CPU Reset 开始，Firmware 加载操作系统内核代码，操作系统成为状态机的管理者，初始化第一个进程，从而成为一个中断处理程序和系统调用执行者。《操作系统》课程的很重要部分就是操作系统中的对象和操纵这些对象的 API——我们已经学习了 fork, execve, exit, 和 mmap (munmap/mprotect)。如何用这些 API，以及更多的 API，实现丰富的应用程序？")])],-1)),i[1]||(i[1]=s("p",null,[s("strong",null,"本讲内容"),e("：一些操作系统 API 的补充；UNIX Shell 实现。")],-1)),t(" more -"),i[2]||(i[2]=n('<h2 id="更多的操作系统-api" tabindex="-1"><a class="header-anchor" href="#更多的操作系统-api"><span>更多的操作系统 API</span></a></h2><p>我们在编程的时候，可以把指针指向任意一个地址空间 <s>(会不会崩溃另说)</s>：</p><div class="language-c" data-highlighter="shiki" data-ext="c" data-title="使用指针来访问对应的地址空间" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">p </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">0x</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1234567</span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">LL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre></div><p>但是你发现，我们似乎无法直接通过上面这种方式来将指针指向 <strong>操作系统中的对象</strong>。</p><blockquote><p>操作系统中的对象：</p><ul><li>文件：有 “名字” 的对象</li><li>可以看成 字节流 (终端) 或字节序列 (普通文件；包括 <code>/proc/*</code>)</li></ul></blockquote><p>有些时候，我们的程序需要获取操作系统对象中的信息来进行一定的处理，那么我们该如何得到指向操作系统对象的指针呢？</p><p>UNIX 的答案是：<strong>文件描述符</strong> 。</p><h3 id="文件描述符" tabindex="-1"><a class="header-anchor" href="#文件描述符"><span>文件描述符</span></a></h3><p>文件描述符的 <strong>定义</strong></p><ul><li>指向操作系统对象的 “指针” <ul><li>Everything is a file</li><li>通过指针可以访问 “一切”</li></ul></li><li>(C/C++程序) 对操作系统对象访问的 <strong>核心</strong> 机制 与 <strong>底层</strong> 途径 <ul><li>open, close, read/write (解引用), lseek (指针内赋值/运算), dup (指针间赋值)</li></ul></li></ul><div class="hint-container info"><p class="hint-container-title">Windows 下的文件描述符</p><p>Windows 中的文件描述符叫做 <em>handle</em> (句柄 <s>神人翻译，但是可以考古</s>)。使用 <code>Ctrl + Shift + Esc</code> 这一组合快捷键打开任务管理器。</p><p>在 <strong>&quot;性能&quot;</strong> 选项卡下的 CPU 数据界面中，你可以看到当前的 &quot;句柄&quot; 个数：</p><figure><img src="'+h+'" alt="查看句柄个数" tabindex="0" loading="lazy"><figcaption>查看句柄个数</figcaption></figure><p>如果按照正经翻译来的话，<em>handle</em> 其实还蛮 &quot;传神&quot; 的：</p><p><em>Handle</em> <strong>(把手；握把；把柄)</strong></p><ul><li>比 <em>file descriptor</em> 更像 “指针”</li><li>你有一个 <em>handle</em> 在我手上，我就可以更好地控制你</li></ul><figure><img src="'+r+`" alt="handle 实例" tabindex="0" loading="lazy"><figcaption>借助handle来更好地操控锅</figcaption></figure><p>如果我们把 <strong>操作系统对象</strong> 想象成上图的 <strong>锅</strong>，把 <strong>文件描述符</strong> 想象成上图的 <strong>&quot;把柄&quot;</strong> ，也许就能够更好地理解文件描述符的作用 —— 在不知道锅内部状态的情况下直接操作锅可能是很 <strong>危险</strong> ⚠️ 的行为！</p><div class="hint-container tip"><p class="hint-container-title">是否感觉 <em>handle</em> 有点熟悉？</p><p>看到 <em>handle</em> 这个词有没有想到 <a href="https://jyywiki.cn/OS/2024/labs/M4.md" target="_blank" rel="noopener noreferrer">M4</a> 中打开共享库时需要进行的操作 <code>dlopen()</code> 呢？</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="打开共享库" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 打开共享库</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">handle </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> dlopen</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;libfoo.so&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> RTLD_LAZY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">handle) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 发生了错误</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div></div><h3 id="管道" tabindex="-1"><a class="header-anchor" href="#管道"><span>管道</span></a></h3><p>操作系统对象除了上述的内容以外，还有一类很特殊的操作系统对象 —— 管道 (pipe)。</p><blockquote><p>详见 <code>man 2 pipe</code></p></blockquote><p>管道由读者/写者共享</p><ul><li>读口：支持 <code>read</code></li><li>写口：支持 <code>write</code></li><li>不能够做出类似于从管道中间取内容的行为！</li></ul><p>UNIX 中提供了 <code>pipe</code> 函数的声明：</p><div class="language-c" data-highlighter="shiki" data-ext="c" data-title="pipe 函数的声明" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> pipe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> pipefd</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre></div><ul><li>返回两个文件描述符 <ul><li><code>pipefd[0]</code> 为读口</li><li><code>pipefd[1]</code> 为写口</li></ul></li><li>如你所见，进程 <strong>同时</strong> 拥有了读口和写口的文件描述符 <ul><li>看起来没用？不，<code>fork</code> 就有用了<br><img src="`+o+'" alt="理解pipe" title="理解pipe" loading="lazy"></li></ul></li></ul><p>管道实际上存在着一些 <strong>同步</strong> 的行为</p><ul><li>读的时候如果没有内容会等待，直到管道中有内容并接收后才会释放</li><li>写的时候如果内容没有被读取会等待，直到管道中有 reader 的时候才将内容写入缓冲区并释放 <ul><li>因为没有 reader 的时候操作系统是不会维护缓冲区的</li><li>writer 打算放入的东西就无处可放，所以会等待</li></ul></li><li>管道其实是有缓冲区的：POSIX 最低标准 512 字节，Linux 4096 字节 <ul><li>如果单次写超过了这个缓冲区的话? <ul><li><span class="spoiler" tabindex="-1">当然是会被拆分成多次 write 啦</span></li><li>去读 <code>man 7 pipe</code> !</li></ul></li></ul></li></ul><h2 id="操作系统的外壳" tabindex="-1"><a class="header-anchor" href="#操作系统的外壳"><span>操作系统的外壳</span></a></h2><figure><img src="'+d+`" alt="计算机各层之间的关系" tabindex="0" loading="lazy"><figcaption>计算机各层之间的关系</figcaption></figure><p>虽然说我们在绪论中为操作系统建模的时候绘制了这么一幅图，并且我们说：</p><ul><li><em>Everything is a state machine</em></li><li>操作系统 = 对象 + API</li><li>操作系统 = C 程序</li><li>...</li></ul><p>但是 <strong>我们眼中的操作系统</strong> 似乎与上面的模型很不一样：</p><ul><li>我们实际上 <strong>&quot;看不到&quot;</strong> 操作系统</li><li>看到的是 <strong>使用系统调用的应用程序</strong></li><li>因此有一个应用程序是特殊的 <ul><li>它可以直接和用户交互</li><li>通过它可以配置操作系统、启动/管理其他应用</li></ul></li></ul><h3 id="shell-——-kernel-的外壳" tabindex="-1"><a class="header-anchor" href="#shell-——-kernel-的外壳"><span><em>Shell</em> —— Kernel 的外壳</span></a></h3><p><em>Shell</em> 是一个特殊的应用程序，它完成了对操作系统内核的封装,实现了 <em>Kernel</em> - <em>Shell</em> - <em>I/O Devices</em> - <em>Human user</em> 之间的连接。</p><p>说到底，其实 UNIX Shell 是一个 <strong>“把用户指令翻译成系统调用”</strong> 的 <strong>编程语言</strong>。</p><ul><li><a href="https://jyywiki.cn/OS/2024/labs/M4.md" target="_blank" rel="noopener noreferrer">M4</a> 中介绍的 <em>repl</em> 与 <em>Shell</em> 也非常相似。 <ul><li>“搭建一个临时工具组合”</li></ul></li></ul><div class="language-less line-numbers-mode" data-highlighter="shiki" data-ext="less" data-title="Shell &amp; C" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">fog-worg</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:pipe/ $ ls </span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ls                                                                             </span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">anonymous-pipe</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  anonymous-pipe</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.c</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  Makefile  </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">named-pipe</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  named-pipe</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.c</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  README</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.md</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">anonymous-pipe</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  anonymous-pipe</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.c</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  Makefile  </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">named-pipe</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  named-pipe</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.c</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  README</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.md</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">list_all_files() </span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">list_all_files()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>优点：高效、简洁、精确</strong></p><ul><li>一种 “自然编程语言”</li><li>短短一行命令，即可协同多个程序执行</li><li>我们已经看过很多例子了 <ul><li><code>make -nB | grep ...</code></li></ul></li></ul><p><strong>缺点：新手不友好</strong></p><ul><li>你需要了解很多工具和它们的命令行参数</li><li><em>“Unix is user-friendly; it&#39;s just choosy about who its friends are.”</em></li></ul><div style="text-align:center;"><p>去从手册中发掘 <em>Shell</em> (对当前的你来说) 的更多可能，相信收获会非常大！</p></div><h2 id="经典复刻之路-level-1-unix-shell" tabindex="-1"><a class="header-anchor" href="#经典复刻之路-level-1-unix-shell"><span>经典复刻之路 Level 1: <em>UNIX Shell</em></span></a></h2><div class="hint-container note"><p class="hint-container-title">重走经典之路</p><p>不知不觉中，我们已经拥有了实现 UNIX 系统内全部机制的系统调用：</p><ul><li><p>进程管理</p><ul><li>fork, execve, exit</li></ul></li><li><p>内存管理</p><ul><li>mmap, munmap, mprotect</li></ul></li><li><p>文件管理</p><ul><li>open, close, read, write, lseek, dup</li></ul></li><li><p>进程间通信</p><ul><li>pipe, wait</li></ul></li></ul><p><s>或许实现 UNIX 系统已经不再是难事了！</s></p><p>🤔 我们可以自己复刻一下 UNIX 系统中的一些内容吗？</p><ul><li>先从最外层开始吧！</li></ul><div class="hint-container info"><p class="hint-container-title">提示</p><p>本节主要是阅读代码为主，因此本节课后续没有记笔记。</p><p>老师主要讲了一下 python + .gdb scripts + gdb 的调试技巧，同时课上还带着调试了一下 xv6 那边的 <em>freestanding shell</em> 的实现。</p><p>强烈建议课后自行阅读并理解 <code>sh.c</code> 这份代码！</p></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>通过 <em>freestanding 的 shell</em>，我们阐释了 <strong>“可以在系统调用上创建整个操作系统应用世界”</strong> 的真正含义：操作系统的 API 和应用程序是互相成就、螺旋生长的：有了新的应用需求，就有了新的操作系统功能。而 UNIX 为我们提供了一个非常精简、稳定的接口 (fork, execve, exit, pipe ,...)，纵然有沉重的历史负担，它在今天依然工作得很好。</p>`,41))])}const A=l(k,[["render",c],["__file","syscall-and-unix-shell.html.vue"]]),y=JSON.parse('{"path":"/zh/note/os/Virtualization/syscall-and-unix-shell.html","title":"系统调用和 UNIX Shell","lang":"zh-CN","frontmatter":{"title":"系统调用和 UNIX Shell","order":16,"icon":"terminal","categories":["操作系统"],"tags":["系统调用","UNIX","Shell"],"description":"背景回顾：整个计算机系统世界的 “创建” 从 CPU Reset 开始，Firmware 加载操作系统内核代码，操作系统成为状态机的管理者，初始化第一个进程，从而成为一个中断处理程序和系统调用执行者。《操作系统》课程的很重要部分就是操作系统中的对象和操纵这些对象的 API——我们已经学习了 fork, execve, exit, 和 mmap (mun...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/zh/note/os/Virtualization/syscall-and-unix-shell.html"}],["meta",{"property":"og:site_name","content":"文档演示"}],["meta",{"property":"og:title","content":"系统调用和 UNIX Shell"}],["meta",{"property":"og:description","content":"背景回顾：整个计算机系统世界的 “创建” 从 CPU Reset 开始，Firmware 加载操作系统内核代码，操作系统成为状态机的管理者，初始化第一个进程，从而成为一个中断处理程序和系统调用执行者。《操作系统》课程的很重要部分就是操作系统中的对象和操纵这些对象的 API——我们已经学习了 fork, execve, exit, 和 mmap (mun..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-15T12:35:11.000Z"}],["meta",{"property":"article:tag","content":"系统调用"}],["meta",{"property":"article:tag","content":"UNIX"}],["meta",{"property":"article:tag","content":"Shell"}],["meta",{"property":"article:modified_time","content":"2025-02-15T12:35:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"系统调用和 UNIX Shell\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-15T12:35:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"codePJCP2\\",\\"url\\":\\"https://docs.pjcp2-personal.cn/zh/\\"}]}"]]},"headers":[{"level":2,"title":"更多的操作系统 API","slug":"更多的操作系统-api","link":"#更多的操作系统-api","children":[{"level":3,"title":"文件描述符","slug":"文件描述符","link":"#文件描述符","children":[]},{"level":3,"title":"管道","slug":"管道","link":"#管道","children":[]}]},{"level":2,"title":"操作系统的外壳","slug":"操作系统的外壳","link":"#操作系统的外壳","children":[{"level":3,"title":"Shell —— Kernel 的外壳","slug":"shell-——-kernel-的外壳","link":"#shell-——-kernel-的外壳","children":[]}]},{"level":2,"title":"经典复刻之路 Level 1: UNIX Shell","slug":"经典复刻之路-level-1-unix-shell","link":"#经典复刻之路-level-1-unix-shell","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1733056361000,"updatedTime":1739622911000,"contributors":[{"name":"codePJCP2","email":"159783914+codePJCP2@users.noreply.github.com","commits":2}]},"readingTime":{"minutes":6.1,"words":1830},"filePathRelative":"zh/note/os/Virtualization/syscall-and-unix-shell.md","localizedDate":"2024年12月1日","autoDesc":true}');export{A as comp,y as data};
